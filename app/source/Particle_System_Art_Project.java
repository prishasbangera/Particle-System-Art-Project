/* autogenerated by Processing revision 1294 on 2025-04-04 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Particle_System_Art_Project extends PApplet {

SampleImage sampleImage;
ParticleSystem pSystem;

final int PIXEL_DENSITY = 2;

String IMAGE_PATH = "";
boolean started = false;
int mouseBrush[] = {2, 2}; // number, spacing

// Handle file input (source: Processing reference)

public void fileSelected(File selection) {
  if (selection == null) {
    println("Window was closed or the user hit cancel.");
  } else {
    IMAGE_PATH = selection.getAbsolutePath();
    println("User selected " + selection.getAbsolutePath());
    
    sampleImage = new SampleImage(IMAGE_PATH);
    sampleImage.getImage().resize(pixelWidth, pixelHeight);
    
    // create the field from the image
    sampleImage.createField();
    
    // init particle system
    pSystem = new ParticleSystem(sampleImage);
    
    println("Ready to draw");
    started = true;
  }
}

public void setup() {
  
  /* size commented out by preprocessor */;
  /* pixelDensity commented out by preprocessor */;
  
  selectInput("Select an image", "fileSelected");
  
}

// add particles on mouse drag

public void mouseDragged() {
  
  if (started) {
    for (int x = -mouseBrush[0]; x < mouseBrush[0]; x++) {
      for (int y = -mouseBrush[0]; y < mouseBrush[0]; y++) {
        pSystem.addParticle(mouseX + x * mouseBrush[1], mouseY + y * mouseBrush[1]);
      }
    }
  }
  
}

// RUN EACH FRAME

public void draw() {
  if (started) {
    pSystem.run();
  }
}

// when f is pressed, save screen to Snapshots folder

public void keyPressed() {
  if (key == 'f') {
    saveFrame("Snapshots\\snapshot-######.png");
  }
}
public class Particle {
  
  // constants to play around with
  private final int VEL_MULTIPLIER = 3;
  private final int RAND_MULTIPLIER = 1;
  private final int STROKE_WEIGHT = 2;
  private final int OPACITY = 20;
  
  private PVector pos;
  private PVector oldPos;
  private PVector vel;
  
  private int clr;
  
  private SampleImage sampleImage;
  
  private int steps = 100;
    
  public Particle(float x, float y, SampleImage sampleImage) {
    
    this.sampleImage = sampleImage;
    
    pos = new PVector(x, y);
    oldPos = new PVector(x, y);
    vel = new PVector(0, 0);
    
    // get color at particle position
    int xInd = Math.round(pos.x) * pixelDensity;
    int yInd = Math.round(pos.y) * pixelDensity;
    int c = color(sampleImage.getImage().get(xInd, yInd));
    clr = color(red(c), green(c), blue(c), OPACITY); // slightly transparent
   
  }
  
  private void update() {
    
    oldPos.x = pos.x;
    oldPos.y = pos.y;
    
    // update - get vector for this pixel
    // vector points in direction of the greatest increase in brightness
    
    int xInd = (int)Math.floor(pos.x) * pixelDensity;
    int yInd = (int)Math.floor(pos.y) * pixelDensity;
    
    float px = sampleImage.field[xInd][yInd][0];
    float py = sampleImage.field[xInd][yInd][1];
    
    float m = sqrt(px * px + py * py);
    
    // trying
    vel.x = VEL_MULTIPLIER*px/m + random(-1,1)*RAND_MULTIPLIER;
    vel.y = VEL_MULTIPLIER*py/m + random(-1,1)*RAND_MULTIPLIER;
    
    // rotate gradient vector by 90 degrees
    pos.x += -vel.y;
    pos.y += vel.x;

    // reduce lifespan
    steps--;

    
  }
  
  public void draw() {
    
    stroke(clr);
    strokeWeight(STROKE_WEIGHT);
    
    line(oldPos.x, oldPos.y, pos.x, pos.y);
    
  }
  
  public boolean isAlive() {
    return steps > 0 && pos.x >= 0 && pos.y >= 0 && pos.x < width && pos.y < height;
  }
  
  // calls the update function
  public void run() {
    draw();
    update();
  }
  
  
}
public class ParticleSystem {
  
  private final int NUM_INIT_PARTICLES = 0;
  private final ArrayList<Particle> particles = new ArrayList<>();
  
  private final SampleImage sampleImage;

  public ParticleSystem(SampleImage sampleImage) {
    
    this.sampleImage = sampleImage;
    for (int i = 0; i < NUM_INIT_PARTICLES; i++) {
      addParticle(random(width), random(height));
    }
  
  }
  
  public void addParticle(float x, float y) {
    particles.add( new Particle(x, y, sampleImage) );
  }
  
  public void run() {
    for (int i = 0; i < particles.size();) {
      Particle p = particles.get(i);
      if (!p.isAlive()) {
        particles.remove(p);
        continue;
      }
      i++;
      p.run();
    }
  }
  

}
public class SampleImage {

  private PImage image;
  public float[][][] field;
  
  // Sobel operator
  
  private final int[][] xKernel = {
    {-1, 0, 1},
    {-2, 0, 2},
    {-1, 0, 1}
  };
  
  private final int[][] yKernel = {
    {-1, -2, -1},
    {0, 0, 0},
    {1, 2, 1}
  };
  
  public SampleImage(String imagePath) {
    try {
      this.image = loadImage(imagePath);
    } catch (Exception e) {
      println("Something went wrong with the file. Please restart the program and try again");
    }
    field = new float[pixelWidth][pixelHeight][2];
  }
  
  public PImage getImage() {
    return image;
  }
  
  public float[] colorToArray(int x, int y) {
     int c;
    synchronized (pixelsLock) {
      c = image.pixels[getPixel(x, y)];
    }
    float[] res = {red(c), green(c), blue(c)};
    return res;
  }
  
  public int getPixel(int x, int y) {
    return (x + y * pixelWidth);
  }
  
  public float calcKernel(int x, int y, int[][] kernel) {
    
    try {
      
      float[][] clrs = {
        colorToArray(x-1,y-1),
        colorToArray(x+0,y-1),
        colorToArray(x+1,y-1),
        colorToArray(x-1,y+0),
        colorToArray(x+0,y+0),
        colorToArray(x+1,y+0),
        colorToArray(x-1,y+1),
        colorToArray(x+0,y+1),
        colorToArray(x+1,y+1)
      };
      
      float res = 0;
    
      for (int i = 0; i < 3; i++) {
        res += (
          kernel[0][0] * clrs[0][i] + 
          kernel[0][1] * clrs[1][i] + 
          kernel[0][2] * clrs[2][i] + 
          kernel[1][0] * clrs[3][i] + 
          kernel[1][1] * clrs[4][i] + 
          kernel[1][2] * clrs[5][i] +  
          kernel[2][0] * clrs[6][i] + 
          kernel[2][1] * clrs[7][i] + 
          kernel[2][2] * clrs[8][i]
        );
      }
      
      res /= 3.0f;
      
      if (res == 0)
        res = random(-0.5f, 0.5f);
        
      return res;
      
    } catch (Exception e) {
      // edge
      if (kernel.equals(xKernel)) {
        return Integer.signum(x - width/2);
      } else {
        return Integer.signum(y - height/2);
      }  
    }
    
  }
  
  
  private final Object pixelsLock = new Object();
  private final Object fieldLock = new Object();
  
  private class PixelRow implements Runnable {
    
    private int x;
    private final float SCALAR = 0.2f; // outline before particles are drawn
        
    public PixelRow(int x) {
      this.x = x;
    }
    
    public void run() {
      
        for (int y = 0; y < pixelHeight; y++) {
          // compute the vector for this pixel
          // central difference (take avg of rgb)
          float partialx = calcKernel(x, y, xKernel);
          
          float partialy = calcKernel(x, y, yKernel);
          
          float magn = sqrt(partialx * partialx + partialy * partialy);
          
          // visual display on canvas
          int i = getPixel(x, y);
          synchronized(pixelsLock) {
            pixels[i] = color(
              (int)(SCALAR * partialx), 
              (int)(SCALAR * partialy), 
              (int)(SCALAR * magn), 255);
          }
          
          // add to field array
          synchronized (fieldLock) {
            field[x][y][0] = partialx;
            field[x][y][1] = partialy;
          }
        }
        
        
    }
           
    
  }
  
  public void createField() {
    
    ArrayList<Thread> threads = new ArrayList<>();
    image.loadPixels();
    loadPixels();
    
    for (int x = 0; x < pixelWidth; x++) {
        Thread t = new Thread(new PixelRow(x));
        threads.add(t);
        t.start();
    }

    
    for (Thread t : threads) {
      try {
        t.join();
      } catch (Exception e) {
        e.printStackTrace();
      }
    }
    
    image.updatePixels();
    updatePixels();
    
  }
  
  
  
  
}


  public void settings() { size(800, 800);
pixelDensity(PIXEL_DENSITY); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Particle_System_Art_Project" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
